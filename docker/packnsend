#!/bin/sh

ROOT_DIRECTORY=$(git rev-parse --show-toplevel)
WORK_DIRECTORY=".`pwd | sed -e s%$ROOT_DIRECTORY%%`"

NR_DOCKER_REPO=cf-registry.nr-ops.net
PYTHON_AGENT_IMG_PATH=$NR_DOCKER_REPO/python-agent

TEST_IMAGE_NAME=python-base

TMPDIR=${TMPDIR:-/tmp}

CONTAINER_ID=""

APP_SERVICE_IMAGES="
    memcached \
    gearmand \
    postgresql \
    mysql \
    devpi \
    mongodb \
    redis \
    elasticsearch \
    solr4
    "

ALL_IMAGES="python-base $APP_SERVICE_IMAGES"
DATE=`date '+%Y%m%d%H%M%S'`

cleanup_containers()
{
    # Remove any docker containers/images and the working directory
    # where we exported the git repository for use in creating the
    # docker image.

    echo "Removing test container $CONTAINER_ID."
    test -n "$CONTAINER_ID" && docker rm -f --volumes $CONTAINER_ID

    echo "Running compose down $COMPOSE_FILE."
    test -n "$COMPOSE_FILE" && docker_compose_down

    echo "Removing test image $DATA_IMAGE_NAME."

    test -n "$DATA_IMAGE_NAME" && docker rmi $DATA_IMAGE_NAME

    echo "Removing data directory $DATA_DIRECTORY."

    test -n "$DATA_DIRECTORY" && rm -r $DATA_DIRECTORY
}

trap "cleanup_containers && exit 255" INT QUIT TERM

create_work_directory()
{
    # Create the work directory where all the files to be included in
    # the docker image will be placed.

    echo "Creating data directory."

    DATA_DIRECTORY=`mktemp -d $TMPDIR/packnsend.XXXXXXXX`

    echo "Data directory: $DATA_DIRECTORY"
}

export_git_repository()
{
    # We need to be in the root directory of the repository workarea for
    # 'git checkout-index' to include everything in the package By using
    # 'git checkout-index' rather than 'git archive' then we can also
    # include anything staged in the git index.

    echo "Exporting local git workarea."

    (cd $ROOT_DIRECTORY; git checkout-index --prefix=$DATA_DIRECTORY/ -a)
}

create_remote_launchers()
{
    # Create the remote launcher scripts to be included in docker image
    # containing the code to be tested.

    echo "Creating remote launcher scripts."

    cat > $DATA_DIRECTORY/packnsend-remote << EOF
#!/bin/sh
. /data/docker/environ
"\$@"
EOF

    # Shouldn't strictly need to do this as all files add to the image
    # by docker will have execute permissions anyway.

    chmod +x $DATA_DIRECTORY/packnsend-remote
}

create_docker_file()
{
    # Create the Dockerfile used to create our image which contains the
    # code to be tested and our remote launcher script.

    echo "Creating Dockerfile for test image."

    cat > $DATA_DIRECTORY/Dockerfile << EOF
FROM $TEST_IMAGE_NAME
ADD . /data
RUN chown -R guest.users /data && \
    chmod 0755 /data
USER guest
ENV HOME /home/guest
VOLUME /data
WORKDIR /data/$WORK_DIRECTORY
EOF
}

create_docker_test_image()
{
    # Build the docker image containing the code to be tested.

    echo "Building test image."

    DATA_IMAGE_NAME="packnsend-${DATE}-$$"
    if test -n "$COMPOSE_FILE"
    then
        (cd $DATA_DIRECTORY && docker-compose \
                --file $COMPOSE_FILE \
                --project-name $DATA_IMAGE_NAME \
                build \
                --force-rm --no-cache packnsend)
    else
        (cd $DATA_DIRECTORY && docker build --no-cache --rm -t $DATA_IMAGE_NAME .)
    fi
}

set_docker_env_vars()
{
    # Read selected env vars from the current environment
    # in order to pass them to the docker run commands.

    # Env vars looked for:
    #       NEW_RELIC_STARTUP_TIMEOUT
    #       NEW_RELIC_SHUTDOWN_TIMEOUT
    #       NEW_RELIC_FAKE_COLLECTOR
    #       NEW_RELIC_PROXY_SCHEME
    #       NEW_RELIC_PROXY_HOST
    #       NEW_RELIC_PROXY_PORT
    #       NEW_RELIC_PROXY_USER
    #       NEW_RELIC_PROXY_PASS
    #       NEW_RELIC_DEVELOPER_MODE

    DOCKER_ENV_VARS=""

    if test -n "$NEW_RELIC_STARTUP_TIMEOUT"
    then
        KEY_VAL="NEW_RELIC_STARTUP_TIMEOUT=$NEW_RELIC_STARTUP_TIMEOUT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_SHUTDOWN_TIMEOUT"
    then
        KEY_VAL="NEW_RELIC_SHUTDOWN_TIMEOUT=$NEW_RELIC_SHUTDOWN_TIMEOUT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_FAKE_COLLECTOR"
    then
        KEY_VAL="NEW_RELIC_FAKE_COLLECTOR=$NEW_RELIC_FAKE_COLLECTOR"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_DEVELOPER_MODE"
    then
        KEY_VAL="NEW_RELIC_DEVELOPER_MODE=$NEW_RELIC_DEVELOPER_MODE"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_SCHEME"
    then
        KEY_VAL="NEW_RELIC_PROXY_SCHEME=$NEW_RELIC_PROXY_SCHEME"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_HOST"
    then
        KEY_VAL="NEW_RELIC_PROXY_HOST=$NEW_RELIC_PROXY_HOST"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_PORT"
    then
        KEY_VAL="NEW_RELIC_PROXY_PORT=$NEW_RELIC_PROXY_PORT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_USER"
    then
        KEY_VAL="NEW_RELIC_PROXY_USER=$NEW_RELIC_PROXY_USER"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi
    if test -n "$NEW_RELIC_PROXY_PASS"
    then
        KEY_VAL="NEW_RELIC_PROXY_PASS=$NEW_RELIC_PROXY_PASS"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi
}

set_docker_extra_args()
{
    # Set DOCKER_EXTRA_ARGS to contain a string of extra arguments that
    # will be passed to the docker run command.

    DOCKER_EXTRA_ARGS=""

    set_docker_env_vars

    if test -n "$DOCKER_ENV_VARS"
    then
        DOCKER_EXTRA_ARGS="$DOCKER_EXTRA_ARGS $DOCKER_ENV_VARS"
    fi
}

set_link_arguments()
{
    LINK_IMGS=""
    for img in $APP_SERVICE_IMAGES
    do
        LINK_IMGS="$LINK_IMGS --link packnsend-$img:$img"
    done
}

launch_remote_command()
{
    # Launch the remote command, wait for it to complete and display
    # the output.

    echo "Setting extra arguments to pass to docker run command."
    set_docker_extra_args

    echo "DOCKER_EXTRA_ARGS:$DOCKER_EXTRA_ARGS"
    echo

    if test -n "$COMPOSE_FILE"
    then
        RUN_CMD="docker-compose \
                --file $DATA_DIRECTORY/$COMPOSE_FILE \
                --project-name $DATA_IMAGE_NAME \
                run -d \
                --rm \
                $DOCKER_EXTRA_ARGS \
                packnsend \
                /data/packnsend-remote $@"
    else
        echo "Setting images to link"
        set_link_arguments
        RUN_CMD="docker run -d --name $DATA_IMAGE_NAME \
                 $DOCKER_EXTRA_ARGS \
                 $LINK_IMGS \
                 $DATA_IMAGE_NAME /data/packnsend-remote $@"

    fi

    echo "Starting test container and running command."
    echo "Command: $@"

    CONTAINER_ID=$($RUN_CMD | tail -n1)
    test -n "$CONTAINER_ID" || exit 1

    STATUS=100

    { docker logs -f $CONTAINER_ID && \
        echo "Calling docker wait." && \
        STATUS=$(docker wait $CONTAINER_ID) ; } || kill $$

    echo

    if test -n "$INTERACTIVE"
    then
        NFMT='--network {{range $k,$v:=.NetworkSettings.Networks}}{{$k}}{{end}}'
        NETWORK=$(docker inspect --format="$NFMT" $CONTAINER_ID)
        ENV_FORMAT_STR='{{range $x:=.Config.Env}}-e {{$x}} {{end}}'
        ENV=$(docker inspect --format="$ENV_FORMAT_STR" $CONTAINER_ID)

        echo "Starting interactive debug shell."
        echo "NETWORK: $NETWORK"
        echo "ENV: $ENV"
        echo "LINK_IMGS: $LINK_IMGS"
        echo

        docker run -t -i --rm -u guest --volumes-from $CONTAINER_ID \
            $DOCKER_EXTRA_ARGS \
            -w /data/$WORK_DIRECTORY \
            $NETWORK \
            $LINK_IMGS \
            $ENV \
            $TEST_IMAGE_NAME /data/packnsend-remote bash
    fi
}

launch_remote_shell()
{
    INTERACTIVE=1
    launch_remote_command true
}

create_docker_base_images()
{
    IMAGE_LIST=${@:-$ALL_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo "Creating docker base images."
    echo "$IMAGE_LIST"

    for IMG in $IMAGE_LIST
    do
        if [ -e "$ROOT_DIRECTORY/docker/$IMG/pre-build.sh" ];
        then
            echo
            echo "Executing pre-build hook: $IMG"
            echo

            (cd $ROOT_DIRECTORY; docker/$IMG/pre-build.sh) || exit 1
        fi

        echo
        echo "Create image: $IMG"
        echo

        (cd $ROOT_DIRECTORY; docker build --rm -t $IMG docker/$IMG) || exit 1

    done
}

docker_compose_down()
{
    echo
    echo "Cleaning up docker compose..."
    echo

    # The redirect to /dev/null for the docker-compose commands below is
    # required for the case where jenkins initiates a job abort. It's currently
    # unknown WHY this redirection is required so if you know, notes would be
    # greatly appreciated.
    #
    # Without the redirect to /dev/null the docker-compose command exits
    # immediately with an exit code of 255 (service containers still running).
    #
    # With the redirect, the exit code is 0 and the compose containers are
    # stopped/removed correctly
    docker-compose \
        --file $DATA_DIRECTORY/$COMPOSE_FILE \
        --project-name $DATA_IMAGE_NAME \
        stop -t 0 &>/dev/null

    docker-compose \
        --file $DATA_DIRECTORY/$COMPOSE_FILE \
        --project-name $DATA_IMAGE_NAME \
        down --volumes --rmi local &>/dev/null

    # Docker compose removes the container, no need to track it further
    CONTAINER_ID=""

    # Docker compose also removes the image, no need to track it further
    DATA_IMAGE_NAME=""
}

create_docker_base_images_nocache()
{
    IMAGE_LIST=${@:-$ALL_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo "Creating docker base images, no cache."
    echo "$IMAGE_LIST"

    for IMG in $IMAGE_LIST
    do
        if [ -e "$ROOT_DIRECTORY/docker/$IMG/pre-build.sh" ];
        then
            echo
            echo "Executing pre-build hook: $IMG"
            echo

            (cd $ROOT_DIRECTORY; docker/$IMG/pre-build.sh) || exit 1
        fi

        echo
        echo "Create image: $IMG"
        echo

        (cd $ROOT_DIRECTORY; docker build --no-cache --rm -t $IMG docker/$IMG) || exit 1

    done
}

push_docker_base_images()
{
    IMAGE_LIST=${@:-$ALL_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo "Push docker base images."
    echo "$IMAGE_LIST"

    for IMG in $IMAGE_LIST
    do

        echo
        echo "Push image: $IMG"
        echo

        docker tag $IMG $PYTHON_AGENT_IMG_PATH/$IMG
        docker push $PYTHON_AGENT_IMG_PATH/$IMG

    done
}

pull_docker_base_images()
{
    IMAGE_LIST=${@:-$ALL_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo "Pull docker base images."
    echo "$IMAGE_LIST"

    for IMG in $IMAGE_LIST
    do

        echo
        echo "Pull image: $IMG"
        echo

        docker pull $PYTHON_AGENT_IMG_PATH/$IMG

        FORCE_TAG_OPERATION="docker tag -f $PYTHON_AGENT_IMG_PATH/$IMG $IMG"
        TAG_OPERATION="docker tag $PYTHON_AGENT_IMG_PATH/$IMG $IMG"

        $FORCE_TAG_OPERATION > /dev/null 2>&1 || $TAG_OPERATION || exit 1

    done
}

start_application_services()
{
    IMAGE_LIST=${@:-$APP_SERVICE_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo
    echo "Start application services."

    for IMG in $IMAGE_LIST
    do

        echo
        echo "Start: $IMG"

        # Is container already running?
        DOCKER_OUTPUT=$(docker ps) || exit 1
        RUNNING_ID=$(echo "$DOCKER_OUTPUT" |
                grep packnsend-$IMG | awk '{print $1}')

        if test -n "$RUNNING_ID"
        then
            echo "$RUNNING_ID is already running."
            continue
        fi

        # Is container in stopped state?
        DOCKER_OUTPUT=$(docker ps -a) || exit 1
        STOPPED_ID=$(echo "$DOCKER_OUTPUT" |
                grep packnsend-$IMG | awk '{print $1}')

        if test -n "$STOPPED_ID"
        then
            echo "$STOPPED_ID was stopped. Now restarting."
            docker start packnsend-$IMG || exit 1
            continue
        fi

        docker run -d --name packnsend-$IMG $IMG || exit 1

    done

    DOCKER_OUTPUT=""
    RUNNING_ID=""
    STOPPED_ID=""
}

stop_application_services()
{
    IMAGE_LIST=${@:-$APP_SERVICE_IMAGES}
    IMAGE_LIST=$(echo $IMAGE_LIST | sed 's/ \+/ /g')

    echo
    echo "Stop application services."

    for IMG in $IMAGE_LIST
    do
        echo
        echo "packnsend-$IMG"

        DOCKER_OUTPUT=$(docker ps -a) || exit 1
        SERVICE_ID=$(echo "$DOCKER_OUTPUT" |
                grep packnsend-$IMG | awk '{print $1}')
        test -n "$SERVICE_ID" && echo "$SERVICE_ID"

        if test -n "$SERVICE_ID"
        then
            docker stop -t=0 "$SERVICE_ID" > /dev/null || exit 1
            docker rm "$SERVICE_ID" > /dev/null || exit 1
        fi

    done

    DOCKER_OUTPUT=""
    SERVICE_ID=""
}

delete_dangling_images()
{
    echo
    echo "Removing dangling images"
    echo
    DANGLING=$(docker images -a -q --filter "dangling=true")
    test -n "$DANGLING" && { echo "$DANGLING" | xargs docker rmi || exit 1; }
}

delete_packnsend_images()
{
    echo
    echo "Delete packnsend images"
    echo
    REMAINING_IMAGES=$(docker images -a \
            --format "{{.Repository}} {{.ID}}" --filter "dangling=false")
    TO_REMOVE=$(echo "$REMAINING_IMAGES" | grep "^packnsend" | cut -f2 -d" ")
    test -n "$TO_REMOVE" && echo "$TO_REMOVE" | xargs docker rmi -f
}

delete_docker_base_images()
{
    IMAGE_LIST=${@:-$ALL_IMAGES}

    echo "Removing docker base images."
    echo "$IMAGE_LIST"

    for IMG in $IMAGE_LIST
    do

        LOCAL_AND_REMOTE="$IMG $PYTHON_AGENT_IMG_PATH/$IMG"
        for IMG_NAME in $LOCAL_AND_REMOTE
        do
            REMAINING_IMAGES=$(docker images -a \
                    --format "{{.Repository}} {{.ID}}" \
                    --filter "dangling=false")
            RELEVANT_IMAGES=$(echo "$REMAINING_IMAGES" |
                    grep "^$IMG_NAME " | cut -f2 -d" ")

            for RELATED_IMG in $RELEVANT_IMAGES
            do
                echo
                echo "Remove image version: $RELATED_IMG"
                echo

                docker rmi -f $RELATED_IMG || exit 1
            done
        done

    done
}

delete_all_containers()
{
    echo
    echo "Removing all containers"
    echo
    CONTAINERS=$(docker ps -a -q)
    test -n "$CONTAINERS" && { echo "$CONTAINERS" | xargs docker rm -f || exit 1; }
}

delete_dangling_volumes()
{
    echo
    echo "Removing all dangling volumes"
    echo
    VOLUMES=$(docker volume ls -f dangling=true -q)
    test -n "$VOLUMES" && { echo "$VOLUMES" | xargs docker volume rm || exit 1; }
}

print_usage()
{
    echo
    echo "`basename $0`: COMMAND [arg...]"
    echo
    echo "Run Commands:"
    echo "    run                    Run command on test container."
    echo "    run -i                 Run command interactively."
    echo "    run -c [compose-file]  Run command using docker-compose."
    echo "    shell                  Launch a shell on test container."
    echo
    echo "Management Commands:"
    echo
    echo "To operate on a subset of images/containers, pass a list"
    echo "of space-separated names of images as arguments to the"
    echo "management commands. Otherwise, management commands operate"
    echo "on all images/containers."
    echo
    echo "    init               Pull images, if authorized, else build."
    echo "    build              Build base images."
    echo "    build_nocache      Build base images, no cache."
    echo "    push               Push base images."
    echo "    pull               Pull base images."
    echo "    start              Start base containers."
    echo "    stop               Stop base containers."
    echo "    refresh            Re-pull the base images,"
    echo "                         remove all containers,"
    echo "                         remove packnsend related images,"
    echo "                         restarts base containers."
    echo "    restart            Stop, then start base containers."
    echo "    cleanup            Delete base images."
    echo
    echo "Help commands:"
    echo "    list           List base images."
    echo "    help           Print help message."
    echo
}

list_docker_base_images()
{
    echo
    echo "Available base images:"
    echo

    for IMG in $ALL_IMAGES
    do
        echo "    $IMG"
    done
}

if test $# -lt 1
then
    print_usage
    exit 1
fi

COMMAND=$1

shift
while test "$#" -ne 0
do
    case $1 in
        -i)
            INTERACTIVE=1
            shift
            ;;
        -c | --compose)
            shift
            COMPOSE_FILE="$1"
            shift
            ;;
        *)
            break
            ;;
    esac
done

case "$COMMAND" in
    run)
        create_work_directory
        export_git_repository
        create_remote_launchers
        create_docker_file
        create_docker_test_image
        launch_remote_command "$@"
        cleanup_containers
        exit `expr $STATUS`
        ;;

    shell)
        create_work_directory
        export_git_repository
        create_remote_launchers
        create_docker_file
        create_docker_test_image
        launch_remote_shell
        cleanup_containers
        exit 0
        ;;

    init)
        pull_docker_base_images "$@"
        ;;

    build)
        create_docker_base_images "$@"
        ;;

    build_nocache)
        create_docker_base_images_nocache "$@"
        ;;

    push)
        push_docker_base_images "$@"
        ;;

    pull)
        pull_docker_base_images "$@"
        ;;

    start)
        start_application_services "$@"
        ;;

    stop)
        stop_application_services "$@"
        ;;

    restart)
        stop_application_services "$@"
        start_application_services "$@"
        ;;

    refresh)
        stop_application_services "$@"
        delete_all_containers
        delete_dangling_images
        delete_packnsend_images
        pull_docker_base_images "$@"
        delete_dangling_images
        start_application_services "$@"
        delete_dangling_volumes
        ;;

    cleanup)
        delete_all_containers
        delete_dangling_images
        delete_packnsend_images
        delete_dangling_volumes
        delete_docker_base_images "$@"
        ;;

    list)
        list_docker_base_images
        ;;

    help)
        print_usage
        ;;

    *)
        print_usage
        exit 1
        ;;
esac

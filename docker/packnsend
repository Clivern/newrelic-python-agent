#!/bin/sh

ROOT_DIRECTORY=$(git rev-parse --show-toplevel)
WORK_DIRECTORY=".`pwd | sed -e s%$ROOT_DIRECTORY%%`"

TEST_IMAGE_NAME=python-base

TMPDIR=${TMPDIR:-/tmp}

IMAGE_ID=""
CONTAINER_ID=""

cleanup_containers()
{
    # Remove any docker containers/images and the working directory
    # where we exported the git repository for use in creating the
    # docker image.

    echo "Removing test container."

    test -n "$CONTAINER_ID" && docker kill $CONTAINER_ID
    test -n "$CONTAINER_ID" && docker rm $CONTAINER_ID

    echo "Removing test image."

    test -n "$IMAGE_ID" && docker rmi $IMAGE_ID

    echo "Removing data directory."

    rm -r $DATA_DIRECTORY
}

trap "cleanup_containers && exit 255" INT QUIT TERM

create_work_directory()
{
    # Create the work directory where all the files to be included in
    # the docker image will be placed.

    echo "Creating data directory."

    DATA_DIRECTORY=`mktemp -d $TMPDIR/packnsend.XXXXXXXX`

    echo "Data directory: $DATA_DIRECTORY"
}

export_git_repository()
{
    # We need to be in the root directory of the repository workarea for
    # 'git checkout-index' to include everything in the package By using
    # 'git checkout-index' rather than 'git archive' then we can also
    # include anything staged in the git index.

    echo "Exporting local git workarea."

    (cd $ROOT_DIRECTORY; git checkout-index --prefix=$DATA_DIRECTORY/ -a)
}

create_remote_launchers()
{
    # Create the remote launcher scripts to be included in docker image
    # containing the code to be tested.
    #
    # XXX Still cannot seem to copy back files from /data of container
    # after finished but can copy from /tmp. Can't even symlink or hard
    # link file from /data into /tmp to allow it to be copied. So make
    # an actual copy of the log file output into /tmp so it can be
    # copied back when done.

    echo "Creating remote launcher scripts."

    cat > $DATA_DIRECTORY/packnsend-remote << EOF
#!/bin/sh
. /data/docker/environ
"\$@" > /data/packnsend.log 2>&1
STATUS=\$?
cp /data/packnsend.log /tmp/packnsend.log
exit \`expr \$STATUS\`
EOF

    cat > $DATA_DIRECTORY/packnsend-bash << EOF
#!/bin/sh
. /data/docker/environ
exec bash
EOF

    # Shouldn't strictly need to do this as all files add to the image
    # by docker will have execute permissions anyway.

    chmod +x $DATA_DIRECTORY/packnsend-remote
    chmod +x $DATA_DIRECTORY/packnsend-bash
}

create_docker_file()
{
    # Create the Dockerfile used to create our image which contains the
    # code to be tested and our remote launcher script.

    echo "Creating Dockerfile for test image."

    cat > $DATA_DIRECTORY/Dockerfile << EOF
FROM $TEST_IMAGE_NAME
ADD . /data
RUN chown -R guest.users /data
RUN chmod 0755 /data
USER guest
ENV HOME /home/guest
VOLUME /data
EOF
}

create_docker_test_image()
{
    # Build the docker image containing the code to be tested.

    echo "Building test image."

    DATA_IMAGE_NAME="packnsend-`date '+%Y%m%d%H%M%S'`-$$"
    (cd $DATA_DIRECTORY && docker build --rm -t $DATA_IMAGE_NAME .)
    IMAGE_ID=$(docker inspect --format='{{.id}}' $DATA_IMAGE_NAME)
}

set_docker_env_vars()
{
    # Read selected env vars from the current environment
    # in order to pass them to the docker run commands.

    # Env vars looked for:
    #       NEW_RELIC_STARTUP_TIMEOUT
    #       NEW_RELIC_SHUTDOWN_TIMEOUT
    #       NEW_RELIC_FAKE_COLLECTOR
    #       NEW_RELIC_PROXY_SCHEME
    #       NEW_RELIC_PROXY_HOST
    #       NEW_RELIC_PROXY_PORT
    #       NEW_RELIC_PROXY_USER
    #       NEW_RELIC_PROXY_PASS

    DOCKER_ENV_VARS=""

    if test -n "$NEW_RELIC_STARTUP_TIMEOUT"
    then
        KEY_VAL="NEW_RELIC_STARTUP_TIMEOUT=$NEW_RELIC_STARTUP_TIMEOUT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_SHUTDOWN_TIMEOUT"
    then
        KEY_VAL="NEW_RELIC_SHUTDOWN_TIMEOUT=$NEW_RELIC_SHUTDOWN_TIMEOUT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_FAKE_COLLECTOR"
    then
        KEY_VAL="NEW_RELIC_FAKE_COLLECTOR=$NEW_RELIC_FAKE_COLLECTOR"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_SCHEME"
    then
        KEY_VAL="NEW_RELIC_PROXY_SCHEME=$NEW_RELIC_PROXY_SCHEME"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_HOST"
    then
        KEY_VAL="NEW_RELIC_PROXY_HOST=$NEW_RELIC_PROXY_HOST"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_PORT"
    then
        KEY_VAL="NEW_RELIC_PROXY_PORT=$NEW_RELIC_PROXY_PORT"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi

    if test -n "$NEW_RELIC_PROXY_USER"
    then
        KEY_VAL="NEW_RELIC_PROXY_USER=$NEW_RELIC_PROXY_USER"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi
    if test -n "$NEW_RELIC_PROXY_PASS"
    then
        KEY_VAL="NEW_RELIC_PROXY_PASS=$NEW_RELIC_PROXY_PASS"
        DOCKER_ENV_VARS="$DOCKER_ENV_VARS -e $KEY_VAL"
    fi
}

set_docker_extra_args()
{
    # Set DOCKER_EXTRA_ARGS to contain a string of extra arguments that
    # will be passed to the docker run command.

    DOCKER_EXTRA_ARGS=""

    set_docker_env_vars

    if test -n "$DOCKER_ENV_VARS"
    then
        DOCKER_EXTRA_ARGS="$DOCKER_EXTRA_ARGS $DOCKER_ENV_VARS"
    fi
}

launch_remote_command()
{
    # Launch the remote command, wait for it to complete and display
    # the output.

    echo "Setting extra arguments to pass to docker run command."
    set_docker_extra_args

    echo "DOCKER_EXTRA_ARGS:$DOCKER_EXTRA_ARGS"
    echo

    INTERACTIVE=""

    while test "$#" -ne 0
    do
        case $1 in
            -i)
                INTERACTIVE=1
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    echo "Starting test container and running command."
    echo "Command: $@"

    CONTAINER_ID=$(docker run -d --name $DATA_IMAGE_NAME \
        $DOCKER_EXTRA_ARGS \
        -w /data/$WORK_DIRECTORY \
        --link packnsend-gearmand:gearmand \
        --link packnsend-memcached:memcached \
        --link packnsend-postgresql:postgresql \
        --link packnsend-mysql:mysql \
        --link packnsend-devpi:devpi \
        --link packnsend-squid:squid \
        --link packnsend-mongodb:mongodb \
        --link packnsend-redis:redis \
        $DATA_IMAGE_NAME /data/packnsend-remote "$@")

    STATUS=$(time docker wait $CONTAINER_ID)

    echo
    echo "Copying back command output."

    docker cp $CONTAINER_ID:/tmp/packnsend.log $DATA_DIRECTORY

    echo "Command output:"
    echo

    cat $DATA_DIRECTORY/packnsend.log

    echo

    if test -n "$INTERACTIVE"
    then
        echo "Starting interactive debug shell."
        echo

        docker run -t -i --rm -u guest --volumes-from $CONTAINER_ID \
            $DOCKER_EXTRA_ARGS \
            -w /data/$WORK_DIRECTORY \
            --link packnsend-gearmand:gearmand \
            --link packnsend-memcached:memcached \
            --link packnsend-postgresql:postgresql \
            --link packnsend-mysql:mysql \
            --link packnsend-devpi:devpi \
            --link packnsend-squid:squid \
            --link packnsend-mongodb:mongodb \
            --link packnsend-redis:redis \
            $TEST_IMAGE_NAME /data/packnsend-bash
    fi
}

launch_remote_shell()
{
    # Launch a remote shell in the container without actually running
    # and command.

    echo "Setting extra vars to pass to test container."
    set_docker_extra_args

    echo "DOCKER_EXTRA_ARGS:$DOCKER_EXTRA_ARGS"
    echo

    echo "Starting test container and running interactive shell."
    echo

    docker run -t -i --rm --name $DATA_IMAGE_NAME \
        $DOCKER_EXTRA_ARGS \
        -w /data/$WORK_DIRECTORY \
        --link packnsend-gearmand:gearmand \
        --link packnsend-memcached:memcached \
        --link packnsend-postgresql:postgresql \
        --link packnsend-mysql:mysql \
        --link packnsend-devpi:devpi \
        --link packnsend-squid:squid \
        --link packnsend-mongodb:mongodb \
        --link packnsend-redis:redis \
        $DATA_IMAGE_NAME /data/packnsend-bash
}

create_docker_base_images()
{
    echo "Creating docker base images."

    echo "Image: python-base"

    (cd $ROOT_DIRECTORY; docker build --rm -t python-base docker/python-base)

    echo "Image: memcached"

    (cd $ROOT_DIRECTORY; docker build --rm -t memcached docker/memcached)

    echo "Image: gearmand"

    (cd $ROOT_DIRECTORY; docker build --rm -t gearmand docker/gearmand)

    echo "Image: postgresql"

    (cd $ROOT_DIRECTORY; docker build --rm -t postgresql docker/postgresql-9.1)

    echo "Image: mysql"

    (cd $ROOT_DIRECTORY; docker build --rm -t mysql docker/mysql-5.5)

    echo "Image: devpi-server"

    (cd $ROOT_DIRECTORY; docker build --rm -t devpi docker/devpi-server)

    echo "Image: squid"

    # Try pulling the squid image from quay.io before building it.

    # If the pull succeeds, tag it and build it, so we end up with an image
    # named 'squid'. Even though the build step is redundant after a successful
    # pull, it doesn't hurt to run 'docker build', since the presence of the
    # cached layers will make the build step very fast.

    # If the pull and/or tag fails, ignore the errors and build it the slow
    # way, without the benefit of cached layers.

    docker pull quay.io/newrelic/python-agent-squid || true

    docker tag quay.io/newrelic/python-agent-squid squid || true

    (cd $ROOT_DIRECTORY; docker build --rm -t squid docker/squid)

    echo "Image: mongodb"

    (cd $ROOT_DIRECTORY; docker build --rm -t mongodb docker/mongodb)

    echo "Image: redis"

    (cd $ROOT_DIRECTORY; docker build --rm -t redis docker/redis)
}

query_push_pull_authorization()
{
    # Determine if we are authorized to push and pull to the docker
    # repository by attempting to pull a non-existent image and checking
    # the HTTP status code in the response.
    #
    #       If we are authorized, status code is 404.
    #       If we are not authorized, status code is 403.
    #
    # Set IS_AUTHORIZED_TO_PUSH_PULL to 'true' or 'false', depending on
    # the response

    DOCKER_REPO=quay.io
    NONEXISTENT_IMAGE=$DOCKER_REPO/newrelic/python-agent-nonexistent

    # Stderr will contain HTTP status code of response. Since we are pulling
    # a non-existent image, we'll always get an error code of some sort.

    PULL_RESPONSE=$(docker pull $NONEXISTENT_IMAGE 2>&1 >/dev/null)

    PULL_RESPONSE_HTTP_STATUS=$(echo "$PULL_RESPONSE" | \
        sed "s/.*HTTP code://" | tr -d [:space:])

    if test $PULL_RESPONSE_HTTP_STATUS = '404'
    then
        IS_AUTHORIZED_TO_PUSH_PULL='true'

    elif test $PULL_RESPONSE_HTTP_STATUS = '403'
    then
        IS_AUTHORIZED_TO_PUSH_PULL='false'

        echo "You are not authorized to push or pull to the docker repository."
        echo "To become authorized, create an account, then run 'docker login'"
        echo "to create a .dockercfg file."
        echo

    else
        # Any HTTP response code except 403 or 404 most likely means push/pull
        # won't work, so set to false and display response code.

        IS_AUTHORIZED_TO_PUSH_PULL='false'

        echo "Error connecting to Docker repository:"
        echo "$PULL_RESPONSE"
        echo
    fi
}

push_docker_base_images()
{
    echo "Push docker base images."
    echo

    query_push_pull_authorization

    if test $IS_AUTHORIZED_TO_PUSH_PULL = 'true'
    then
        echo "Push image: python-base"
        echo
        docker tag python-base quay.io/newrelic/python-agent-python-base
        docker push quay.io/newrelic/python-agent-python-base
        echo

        echo "Push image: memcached"
        echo
        docker tag memcached quay.io/newrelic/python-agent-memcached
        docker push quay.io/newrelic/python-agent-memcached
        echo

        echo "Push image: gearmand"
        echo
        docker tag gearmand quay.io/newrelic/python-agent-gearmand
        docker push quay.io/newrelic/python-agent-gearmand
        echo

        echo "Push image: postgresql"
        echo
        docker tag postgresql quay.io/newrelic/python-agent-postgresql
        docker push quay.io/newrelic/python-agent-postgresql
        echo

        echo "Push image: mysql"
        echo
        docker tag mysql quay.io/newrelic/python-agent-mysql
        docker push quay.io/newrelic/python-agent-mysql
        echo

        echo "Push image: devpi"
        echo
        docker tag devpi quay.io/newrelic/python-agent-devpi
        docker push quay.io/newrelic/python-agent-devpi
        echo

        echo "Push image: squid"
        echo
        docker tag squid quay.io/newrelic/python-agent-squid
        docker push quay.io/newrelic/python-agent-squid
        echo

        echo "Push image: mongodb"
        echo
        docker tag mongodb quay.io/newrelic/python-agent-mongodb
        docker push quay.io/newrelic/python-agent-mongodb
        echo

        echo "Push image: redis"
        echo
        docker tag redis quay.io/newrelic/python-agent-redis
        docker push quay.io/newrelic/python-agent-redis
        echo

    else
        echo "Skipping docker push."
        echo
    fi
}

start_application_services()
{
    echo "Start application services."

    echo "Application: memcached"

    docker run -d --name packnsend-memcached memcached

    echo "Application: gearmand"

    docker run -d --name packnsend-gearmand gearmand

    echo "Application: postgresql"

    docker run -d --name packnsend-postgresql postgresql

    echo "Application: mysql"

    docker run -d --name packnsend-mysql mysql

    echo "Application: devpi"

    docker run -d --name packnsend-devpi devpi

    echo "Application: squid"

    docker run -d --name packnsend-squid squid

    echo "Application: mongodb"

    docker run -d --name packnsend-mongodb mongodb

    echo "Application: redis"

    docker run -d --name packnsend-redis redis
}

stop_application_services()
{
    echo "Stop application services."

    echo "Application: gearmand"

    docker stop -t=10 packnsend-gearmand
    docker kill packnsend-gearmand
    docker rm packnsend-gearmand

    echo "Application: memcached"

    docker stop -t=10 packnsend-memcached
    docker kill packnsend-memcached
    docker rm packnsend-memcached

    echo "Application: postgresql"

    docker stop -t=10 packnsend-postgresql
    docker kill packnsend-postgresql
    docker rm packnsend-postgresql

    echo "Application: mysql"

    docker stop -t=10 packnsend-mysql
    docker kill packnsend-mysql
    docker rm packnsend-mysql

    echo "Application: devpi"

    docker stop -t=10 packnsend-devpi
    docker kill packnsend-devpi
    docker rm packnsend-devpi

    echo "Application: squid"

    docker stop -t=10 packnsend-squid
    docker kill packnsend-squid
    docker rm packnsend-squid

    echo "Application: mongodb"

    docker stop -t=10 packnsend-mongodb
    docker kill packnsend-mongodb
    docker rm packnsend-mongodb

    echo "Application: redis"

    docker stop -t=10 packnsend-redis
    docker kill packnsend-redis
    docker rm packnsend-redis
}

delete_docker_base_images()
{
    echo "Removing docker base images."

    echo "Image: gearmand"

    docker rmi gearmand

    echo "Image: memcached"

    docker rmi memcached

    echo "Image: postgresql"

    docker rmi postgresql

    echo "Image: mysql"

    docker rmi mysql

    echo "Image: devpi"

    docker rmi devpi

    echo "Image: squid"

    docker rmi squid

    echo "Image: mongodb"

    docker rmi mongodb

    echo "Image: redis"

    docker rmi redis

    echo "Image: python-base"

    docker rmi python-base
}

if test $# -lt 1
then
    echo "Usage: `basename $0`: COMMAND [arg...]"
    exit 1
fi

COMMAND=$1

shift

case "$COMMAND" in
    run)
        create_work_directory
        export_git_repository
        create_remote_launchers
        create_docker_file
        create_docker_test_image
        launch_remote_command "$@"
        cleanup_containers
        exit `expr $STATUS`
        ;;

    shell)
        create_work_directory
        export_git_repository
        create_remote_launchers
        create_docker_file
        create_docker_test_image
        launch_remote_shell
        cleanup_containers
        exit 0
        ;;

    init)
        create_docker_base_images
        ;;

    push)
        push_docker_base_images
        ;;

    start)
        start_application_services
        ;;

    stop)
        stop_application_services
        ;;

    cleanup)
        delete_docker_base_images
        ;;

    *)
        echo "`basename $0`: Unknown command $COMMAND"
        exit 1
        ;;
esac
